import ILMPostProcessing: compute_trajectory


"""
    compute_trajectory(elements,X₀::Vector,Tmax[,Δt=0.001])

Calculate the trajectory of a particle with initial location `X₀`. The
argument `elements` is a potential flow `Element` type or group of `Element` types.
`Tmax` is the final integration time, and `Δt` is the time step size. The output is the solution
structure for the `OrdinaryDiffEq` package.
"""
function compute_trajectory(elements, X₀::Vector{S}, Tmax; Δt=ILMPostProcessing.DEFAULT_DT,alg=ILMPostProcessing.DEFAULT_ALG,kwargs...) where S <: Real

  function vfcn!(dR,R,p,t)
    dR_complex = induce_velocity(R[1]+im*R[2], elements, t)
    dR[1] = real(dR_complex)
    dR[2] = imag(dR_complex)
    return dR
  end

  u0 = ILMPostProcessing._prepare_initial_conditions(X₀)
  sol = ILMPostProcessing._solve_trajectory(vfcn!,X₀,Tmax,Δt,alg;kwargs...)
  return Trajectories(sol)

end

"""
   compute_trajectories(elements,tracer_start,Tmax[,Δt=0.001])

Calculate the trajectories of a set of tracer particles in a potential flow
generated by the elements `elements`. The tracers' initial positions are
provided as a vector of complex positions in `tracer_start`. The final time
and time step are provided as `Tmax` and `Δt`. The output is a tuple of arrays
of the x and y coordinates of the trajectories. Each column of these
arrays corresponds to a single tracer history.
"""
function compute_trajectories(elements, tracer_start::Vector{<:Number}, Tmax; Δt=ILMPostProcessing.DEFAULT_DT,alg=ILMPostProcessing.DEFAULT_ALG,kwargs...)

   tracer_x = []
   tracer_y = []
   for z0 in tracer_start
       traj = compute_trajectory(elements,[real(z0),imag(z0)],Tmax;Δt=Δt,alg=alg,kwargs...)
       xj, yj = traj[1]
       push!(tracer_x,xj)
       push!(tracer_y,yj)
   end
   x = hcat(tracer_x...)
   y = hcat(tracer_y...)

   return x, y

end
